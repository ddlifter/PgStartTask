# PgStartTask

Отчет по выполнению задания для DBA-разработчика
- [Окружение](#окружение)
- [ОптимизацияЗапроса](#ОптимизацияЗапроса)
- [СозданиеИндекса](#Созданиеиндекса)

**Для начала было необходимо развернуть рабочее окружение:**


## Окружение
1. Клонирование репозитория и запуск рабочего окружения
Для начала работы с заданием необходимо клонировать репозиторий и запустить рабочее окружение. Это делается с помощью следующих команд:

```
git clone https://github.com/pkonotopov/ndxg65cdMD2zudNrK4bNXtFuRkJ92V test-env
cd./test-env
docker compose up -d
```
![image](https://github.com/ddlifter/PgStartTask/assets/132294753/cd38b82f-1f43-4418-8ee2-04d425e6d7db)


2. Соединение с БД interview
Для подключения к базе данных interview, используемой в проекте, можно воспользоваться следующей командой:

```
docker compose exec postgres psql -U postgres interview
```
Эта команда позволяет выполнить SQL-запросы к базе данных interview через интерфейс psql.
![image](https://github.com/ddlifter/PgStartTask/assets/132294753/20cb6172-c8be-4011-821f-ec8bbb2976f2)


3. Вывод журналов работы контейнеров
Для мониторинга работы контейнеров можно использовать следующие команды:

Вывод состояния контейнеров:
```
docker compose ps -a
```
Вывод журналов работы всех контейнеров:
```
docker compose logs
```
Вывод журналов работы для конкретного контейнера (например, postgres):
```
docker compose logs postgres
```
Эти команды помогают отслеживать работу контейнеров и выявлять возможные проблемы.
![image](https://github.com/ddlifter/PgStartTask/assets/132294753/fd234f0c-7487-4344-a87d-50a308859597)

4. Перезапуск стека с переинициализацией БД
Для перезапуска стека и переинициализации базы данных можно использовать следующие команды:

```
docker compose down
docker volume rm dba_postgres_volume && docker-compose up -d
```
Команда docker compose down останавливает и удаляет контейнеры, а docker volume rm dba_postgres_volume удаляет том с базой данных. Затем, с помощью docker-compose up -d система запускается снова.

5. Соединение с Metabase
Для доступа к Metabase в браузере достаточно открыть ссылку http://localhost:13030.
![image](https://github.com/ddlifter/PgStartTask/assets/132294753/4aa4995f-171e-4e40-a788-2fcc8ada0937)

## ОптимизацияЗапроса
Выбор методов оптимизации для запроса к базе данных: 
В моем случае, замена ILIKE на LIKE и использование gin индексов были выбраны для максимальной оптимизации времени выполнения запроса и его производительности.

Замена ILIKE на LIKE

ILIKE используется для выполнения поиска без учета регистра, в то время как LIKE требует точного совпадения символов. В вашем запросе, если целью является поиск слов "postgres" и "awesome" в поле body, использование LIKE вместо ILIKE может быть предпочтительным, если регистр важен для вашего запроса. Однако, если регистр не имеет значения, использование ILIKE было бы более подходящим.

Индексы

GIN Индексы позволяют быстро находить совпадения по частям слов или фразам, что особенно полезно для поиска по текстовым полям.
Они поддерживают различные операторы сравнения, такие как LIKE, ILIKE, ~, ~*, что делает их универсальными для различных видов поисковых запросов.
Использование GIN индексов обеспечивает масштабируемость и эффективность даже для больших объемов данных.

Для применения этих индексов необходимо использовать расширение:
![image](https://github.com/ddlifter/PgStartTask/assets/132294753/432f6f18-f52f-4930-a48a-8c79fbdfbfe4)
Опция CONCURRENTLY позволяет создать индекс без блокировки таблицы, что делает процесс более удобным для больших баз данных.

Исходный запрос:
![image](https://github.com/ddlifter/PgStartTask/assets/132294753/f4b7e9a8-e9d9-4810-bbe0-283d07cc751e)
Как мы видим, время выполнения - 2360 ms, производительность - 29342

Итоговый запрос:
![image](https://github.com/ddlifter/PgStartTask/assets/132294753/07388efa-8bc2-4926-823b-b2df800ff9ca)
Время выполнения - 7 ms, производительность - 1039

Кратное улучшение эффективности запроса!

Анализируя два запроса можно также добавить, что изначально планировщик решил разбить весь процесс на два воркера и использовал прямое сканирование, кроме того сильно ошибся в в запланированном и фактическом времени запроса.
В итоговом запросе планировщик уже не так сильно ошибся в планировании времени, использовал уже Index Scan вместо обычного Seq, а также использовал битовый массив(BitMap Heap).


## СозданиеИндекса
Если база данных активно используется и подвергается нагрузке, использование простого запроса CREATE INDEX для создания индекса может быть неэффективным. Это связано с тем, что такая операция блокирует все текущие транзакции до завершения создания индекса, что может занять значительное время и вызвать различные проблемы.

В случае необходимости создания индекса, рекомендуется использовать флаг CONCURRENTLY(как это было показано ранее). Этот подход позволяет PostgreSQL создавать индекс без блокировки записей в таблице, что увеличивает нагрузку на процессор и память, но обеспечивает возможность построения индекса. 

К счастью, в PostgreSQL присутствуют параметры, позволяющие ускорить создание индексов во время высокой нагрузки на базу данных, например:

maintenance_work_mem - количество доступной памяти;

max_parallel_workers - максимальное количество параллеьных воркеров;

max_worker_processes - максимальное количество самих воркеров;


